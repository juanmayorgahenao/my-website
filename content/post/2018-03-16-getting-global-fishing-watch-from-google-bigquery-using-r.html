---
title: Getting Global Fishing Watch from Google BigQuery using R
author: Juan S. Mayorga
date: '2018-03-16'
slug: getting-global-fishing-watch-from-google-bigquery-using-r
categories: []
tags: []
draft: true
---



<p>This blog post explains a couple of workflows to connect to Big Query using <code>R</code>, and access Global Fishing Watch’s public data. Since you found this post, I’m going to assume that you are somewhat familiar with Global Fishing Watch and are looking to explore and analyze the data using <code>R</code>. If you are not, check out our Science publication <a href="http://science.sciencemag.org/content/359/6378/904">Tracking the global footprint of fisheries</a> as well as <a href="http://globalfishingwatch.io/">Global Fishing Watch Open Data</a> portal.</p>
<div id="what-is-bigquery" class="section level1">
<h1>What is BigQuery</h1>
<p><a href="https://bigquery.cloud.google.com/welcome">BigQuery</a> is Google’s platform to store and analyze massive datasets. It is very fast and well integrated to other Google products such as cloud storage, and it’s free to use for up to 1TB of data anlyzed each month, and up to 10GB of data stored. As any other database, it understands SQL and the online editor is a friendly place to learn and troubleshoot your queries.</p>
<p>To start using BigQuery, you need to have a gmail account and a BigQuery-enabled project. If you don’t have this yet, please follow the steps in this quickstart guide <a href="https://cloud.google.com/bigquery/quickstart-web-ui">quickstart guide</a> and come back when done.</p>
</div>
<div id="global-fishing-watchs-data-in-bigquery" class="section level1">
<h1>Global Fishing Watch’s data in BigQuery</h1>
<p>Noow that you have a BigQuery-enabled project, go the <a href="https://bigquery.cloud.google.com">BigQuery’s UI page</a>. You should see your project in the side bar, above the Public Datasets project. Click on the small arrow next to your project name, then switch to project -&gt; display project, and enter “global-fishing-watch” (without the quotes) on the Project ID. Click OK, and you should then have a <code>global-fishing-watch</code> project in your side bar. This project contains, two datasets: <code>&quot;gfw_public_data&quot;</code> and <code>&quot;globa_footprint_of_fisheries&quot;</code>. We will work on the latter, which contains the public data released with the <em>Science</em> publication. This dataset contains four tables</p>
<ul>
<li><code>fishing_effort</code>: Daily Fishing Effort and Vessel Presence at 100th Degree Resolution by Flag State and GearType, 2012-2016</li>
<li><code>fishing_effort_byvessel</code>:Daily Fishing Effort at 10th Degree Resolution by MMSI, 2012-2016</li>
<li><code>fishing_vessels</code>: Characteristics of each vessel included in the effort data</li>
<li><code>vessels</code>: This table includes all vessels that were matched to a regsitry, were identified through manual review or web searchers, or were classified by the neural network.</li>
</ul>
</div>
<div id="establishing-a-connection" class="section level1">
<h1>Establishing a connection</h1>
<p>The first step to use the data from R, is to set a connection with BigQuery. This is done using the <code>DBI</code> and <code>bigrquery</code> packages:</p>
<pre class="r"><code>library(DBI)
library(bigrquery)

BQ_connection &lt;-  dbConnect(dbi_driver(), 
                            project = &#39;global-fishing-watch&#39;,
                            dataset = &quot;global_footprint_of_fisheries&quot;, 
                            billing = &quot;ng-gfw&quot;)</code></pre>
<p>We then need to authenticate the connection. This can be done when running your first query such as listing the tables in your connection through the function <code>dbListTable()</code>. This will trigger a promp in your R session asking if you want to cache your credentials. Allow access and return to RStudio.</p>
<pre class="r"><code>DBI::dbListTables(BQ_connection)</code></pre>
<pre><code>## Auto-refreshing stale OAuth token.</code></pre>
<pre><code>## [1] &quot;fishing_effort&quot;          &quot;fishing_effort_byvessel&quot;
## [3] &quot;fishing_vessels&quot;         &quot;vessels&quot;</code></pre>
<p>Now we are all set to start querying and analysing Global Fishing Watch’s data. There are a couple of approaches to do this, and I will illustrate each one with the following use cases</p>
<ol style="list-style-type: decimal">
<li>Summarize the number of vessels by flag state in 2016</li>
<li>Make a time series of fishing effort for China’s trawlers fleet</li>
<li>Make a map of fishing effort for a particular region of the ocean</li>
</ol>
</div>
<div id="summarize-the-number-of-vessels-by-flag-state" class="section level1">
<h1>1. Summarize the number of vessels by flag state</h1>
<p>This is possibly one the first and simplest queries to do. For this use case, we will use the <code>dbplyr</code> and <code>bigrquery</code> packages that allow us to avoid the need to write SQL. We just write the <code>dplyr</code> verbs and functions we all love, and the <code>dbplyr</code> package translates them into SQL in the backend. The main advantages of this approach is that it’s very friendly and readable, and prevents us from the congnitive dissonance of switching between programming languages. However, SQL is a very large language and <code>dbplyr</code> does not do everything; it focuses on <code>SELECT</code> statements which are often what we use the most.</p>
<p>The first step here is to connect to the table we want to query using the <code>tbl()</code> function:</p>
<pre class="r"><code>library(tidyverse) #loads dplyr and friends

fishing_vessels &lt;- dplyr::tbl(BQ_connection, &quot;fishing_vessels&quot;)</code></pre>
<p>However, notice that the variable created in your environment is not a dataframe or tibble but instead a list. This is because <code>tbl()</code> creates a reference to the table in the remote database but does not bring the actual data into memory. When you print it out, you’ll see it looks like a tibble but its class is <code>tbl_sql</code>.</p>
<pre class="r"><code>fishing_vessels</code></pre>
<pre><code>## # Source:   table&lt;fishing_vessels&gt; [?? x 11]
## # Database: BigQueryConnection
##         mmsi flag  geartype     length tonnage engine_power active_2012
##        &lt;int&gt; &lt;chr&gt; &lt;chr&gt;         &lt;dbl&gt;   &lt;dbl&gt;        &lt;dbl&gt; &lt;lgl&gt;      
##  1 603100157 AGO   trawlers       32.8    299.         734. FALSE      
##  2 603100137 AGO   trawlers       34.6    396.         865. FALSE      
##  3 603100161 AGO   trawlers       28.8    264.         652. FALSE      
##  4 603100174 AGO   trawlers       30.7    300.         704. FALSE      
##  5 603100164 AGO   trawlers       37.5    406.         851. FALSE      
##  6 603100139 AGO   trawlers       27.4    277.         749. FALSE      
##  7 603100175 AGO   trawlers       32.4    442.         889. FALSE      
##  8 603100159 AGO   trawlers       37.8    444.         887. FALSE      
##  9 603100160 AGO   trawlers       32.4    396.         812. FALSE      
## 10 603703900 AGO   purse_seines   36.8    292.        1182. TRUE       
## # ... with more rows, and 4 more variables: active_2013 &lt;lgl&gt;,
## #   active_2014 &lt;lgl&gt;, active_2015 &lt;lgl&gt;, active_2016 &lt;lgl&gt;</code></pre>
<pre class="r"><code>class(fishing_vessels)</code></pre>
<pre><code>## [1] &quot;tbl_dbi&quot;  &quot;tbl_sql&quot;  &quot;tbl_lazy&quot; &quot;tbl&quot;</code></pre>
<p>The most important difference between a local ordinary dataframe and a remote dataframe of class <code>tbl_sql</code> is that the your R code will run in the database. To do this efficiently, <code>dplyr</code> will be as lazy as possible by 1) not pulling data into R unless explicitly asked to, and 2) delaying the actual communication to the database until the last possible moment (i.e., after it collects all that you want to do).</p>
<p>Now, we can continue to use the dplyr verbs we are familiar with and summarize the table as we wish:</p>
<pre class="r"><code>summary_by_country_and_gear &lt;- fishing_vessels %&gt;% 
  filter(active_2016) %&gt;% 
  group_by(flag, geartype) %&gt;% 
  summarize(n_vessels = n_distinct(mmsi),
            total_GT = sum(tonnage)) %&gt;% 
  arrange(desc(n_vessels))</code></pre>
<p>As you will see, the object created in our environment is not the data we wanted. In fact the above code never touched the database, only recorded the instructions to query the data. To pull the data into a local <code>tibble</code> we need to explicitly ask for it with the function <code>collect()</code>.</p>
<pre class="r"><code>summary_by_country_and_gear &lt;- collect(summary_by_country_and_gear)</code></pre>
<p>By not assigning the queried data to an R object, this approach also allows us to make plots that query the data directly in the database.</p>
<pre class="r"><code>fishing_vessels %&gt;% 
  filter(active_2016) %&gt;% 
  group_by(flag, geartype) %&gt;% 
  summarize(n_vessels = n_distinct(mmsi),
            total_GT = sum(tonnage)) %&gt;% 
  arrange(desc(n_vessels)) %&gt;% 
  head(10) %&gt;% 
  ggplot()+
  geom_col(aes(x = flag, y = n_vessels, fill = geartype))+
  theme_bw()+
  ggsci::scale_fill_startrek()</code></pre>
<p><img src="/post/2018-03-16-getting-global-fishing-watch-from-google-bigquery-using-r_files/figure-html/unnamed-chunk-7-1.png" width="1344" style="display: block; margin: auto;" /></p>
<p>Chinese Trawlers are, by far, the largest fleet in the Global Fishing Watch Database.</p>
<p>This approach is straigth forward and works perfectly for simple queries. However, it is not yet capable of doing many SQL statements, and thus I recommend to become proficient with SQL to make the most of the power of BigQuery and Global Fishing Watch. This will help you troubleshoot when things don’t work as expected and it will make it easier to reach out to the Global Fishing Watch community for help. A couple of great resources to learn are: <a href="https://www.codecademy.com/learn/learn-sql">Learn SQL | Codecademy</a>, and <a href="https://learncodethehardway.org/sql/">Learn SQL the Hard Way</a>. Another way to start learning SQL is to use the function <code>show_query()</code> from <code>dplyr</code>, whichwill show you what your R code is being translated as in SQL.</p>
<pre class="r"><code>fishing_vessels %&gt;% 
  filter(active_2016) %&gt;% 
  group_by(flag, geartype) %&gt;% 
  summarize(n_vessels = n_distinct(mmsi),
            total_GT = sum(tonnage)) %&gt;% 
  arrange(desc(n_vessels)) %&gt;% 
  show_query()</code></pre>
<pre><code>## &lt;SQL&gt;
## SELECT [flag], [geartype], COUNT(DISTINCT [mmsi]) AS [n_vessels], SUM([tonnage]) AS [total_GT]
## FROM [fishing_vessels]
## WHERE ([active_2016])
## GROUP BY [flag], [geartype]
## ORDER BY [n_vessels] DESC</code></pre>
</div>
<div id="make-a-time-series-of-fishing-effort-for-chinas-trawlers-fleet" class="section level1">
<h1>2. Make a time series of fishing effort for China’s trawlers fleet</h1>
<p>For this analysis we need to summarize fishing by date for only Chinese trawlers from 2013-2016.</p>
<pre class="r"><code>fishing_vessels &lt;- dplyr::tbl(BQ_connection, &quot;fishing_vessels&quot;)

fishing_effort_byvessel &lt;- dplyr::tbl(BQ_connection, &quot;fishing_effort_byvessel&quot;)

fishing_effort_byvessel %&gt;% 
  inner_join(fishing_vessels %&gt;% 
               filter(flag == &quot;CHN&quot; ), by = &quot;mmsi&quot;) %&gt;% 
  head()</code></pre>
<pre><code>## Error: Field &#39;TBL_LEFT].[date&#39; not found on either side of the JOIN</code></pre>
</div>
